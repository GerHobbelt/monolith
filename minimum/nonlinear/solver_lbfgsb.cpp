#include <cstdio>
#include <iomanip>
#include <iostream>
#include <limits>
#include <stdexcept>

#include <Eigen/Dense>

#include <minimum/core/check.h>
#include <minimum/core/string.h>
#include <minimum/core/time.h>
#include <minimum/nonlinear/solver.h>
using minimum::core::check;
using minimum::core::wall_time;

#include "lbfgsb.h"

namespace minimum {
namespace nonlinear {

void LBFGSBSolver::solve(const Function& function, SolverResults* results) const {
	using namespace std;

	// We wish to have output at every 10th iteration.
	long iprint = 10;
	// For now, disable output if we donâ€™t have any log function.
	// There is no easy way to capture stdout.
	if (!log_function) {
		iprint = -1;
	}

	long n = function.get_number_of_scalars();
	long m = lbfgs_history_size;

	vector<double> wa(2 * m * n + 11 * m * m + 5 * n + 8 * m);
	vector<long> iwa(3 * n * m);
	long csave;
	vector<long> lsave(4);
	vector<long> isave(44);
	vector<double> dsave(29);

	Eigen::VectorXd x(n);
	function.copy_user_to_global(&x);
	Eigen::VectorXd g(n);
	double f = function.evaluate(x, &g);

	// factr is a DOUBLE PRECISION variable that must be set by the user.
	// 	It is a tolerance in the termination test for the algorithm.
	// 	The iteration will stop when
	//
	// 	(f^k - f^{ k + 1 }) / max{ | f^k | , | f^{ k + 1 } | ,1 } <= factr*epsmch
	//
	// where epsmch is the machine precision which is automatically
	// generated by the code.Typical values for factr on a computer
	// 	with 15 digits of accuracy in double precision are :
	// factr = 1.d + 12 for low accuracy;
	// 1.d + 7  for moderate accuracy;
	// 1.d + 1  for extremely high accuracy.
	// 	The user can suppress this termination test by setting factr = 0.
	double factr = 1e7;  // default value in driver.
	factr = function_improvement_tolerance / std::numeric_limits<double>::epsilon();
	// pgtol is a double precision variable.
	//	On entry pgtol >= 0 is specified by the user.The iteration
	//	will stop when
	//
	//	    max{ | proj g_i | i = 1, ..., n } <= pgtol
	// where pg_i is the ith component of the projected gradient.
	// The user can suppress this termination test by setting pgtol = 0.
	double pgtol = 1e-5;  // default value in driver.
	double normg = std::max(g.maxCoeff(), -g.minCoeff());
	pgtol = gradient_tolerance * normg;

	vector<long> nbd(n);
	vector<double> l(n);
	vector<double> u(n);
	auto bounds = function.get_all_variable_bounds();
	const double inf = Interval<double>::infinity;
	for (int j = 0; j < n; ++j) {
		l[j] = bounds[j].get_lower();
		u[j] = bounds[j].get_upper();
		if (l[j] == -inf && u[j] == inf) {
			nbd[j] = 0;
		} else if (u[j] == inf) {
			nbd[j] = 1;
		} else if (l[j] == -inf) {
			nbd[j] = 3;
		} else {
			minimum_core_assert(l[j] <= u[j]);
			nbd[j] = 2;
		}
	}

	int iter = 0;
	long task = START;
	while (true) {
		if (iter >= this->maximum_iterations) {
			task = STOP_ITER;
		}

		setulb(&n,
		       &m,
		       x.data(),
		       l.data(),
		       u.data(),
		       nbd.data(),
		       &f,
		       g.data(),
		       &factr,
		       &pgtol,
		       wa.data(),
		       iwa.data(),
		       &task,
		       &iprint,
		       &csave,
		       lsave.data(),
		       isave.data(),
		       dsave.data());
		if (IS_FG(task)) {
			f = function.evaluate(x, &g);
		} else if (task == NEW_X) {
			if (callback_function) {
				CallbackInformation information;
				information.objective_value = f;
				information.x = &x;
				information.g = &g;
				if (!callback_function(information)) {
					task = STOP_USER;
				}
			}

			int log_interval = 1;
			if (iter > 30) {
				log_interval = 10;
			}
			if (iter > 200) {
				log_interval = 100;
			}
			if (iter > 2000) {
				log_interval = 1000;
			}
			if (log_function && iter % log_interval == 0) {
				if (iter == 0) {
					this->log_function("Itr       f     max|g_i|   constr.");
				}
				this->log_function(minimum::core::to_string(std::setw(4),
				                                            iter,
				                                            " ",
				                                            std::setw(10),
				                                            std::setprecision(3),
				                                            std::scientific,
				                                            std::showpos,
				                                            dsave[1],
				                                            std::noshowpos,
				                                            " ",
				                                            std::setw(9),
				                                            std::setprecision(3),
				                                            std::setprecision(3),
				                                            std::scientific,
				                                            dsave[12],
				                                            " ",
				                                            std::setw(7),
				                                            isave[38]));
			}
			iter++;
		} else {
			if (IS_CONVERGED(task)) {
				if (task == CONV_GRAD) {
					results->exit_condition = SolverResults::GRADIENT_TOLERANCE;
				} else if (task == CONV_F) {
					results->exit_condition = SolverResults::FUNCTION_TOLERANCE;
				} else {
					check(false, "Unknown task value from L-BFGS-B: " + to_string(task) + ".");
				}
			} else if (IS_STOP(task)) {
				results->exit_condition = SolverResults::NO_CONVERGENCE;
				if (task == STOP_GRAD) {
					results->exit_condition = SolverResults::GRADIENT_TOLERANCE;
				} else if (task == STOP_USER) {
					results->exit_condition = SolverResults::USER_ABORT;
				}
			} else if (IS_WARNING(task)) {
				results->exit_condition = SolverResults::NO_CONVERGENCE;
			} else if (IS_ERROR(task)) {
				results->exit_condition = SolverResults::INTERNAL_ERROR;
			} else {
				check(false, "Unknown task value from L-BFGS-B: " + to_string(task) + ".");
			}
			break;
		}
	}

	function.copy_global_to_user(x);

	if (this->log_function) {
		char str[1024];
		std::sprintf(str, " end %+.3e           %.3e", f, std::max(g.maxCoeff(), -g.minCoeff()));
		this->log_function(str);
		this->log_function("L-BFGS-B terminated with code " + to_string(task) + ".");
	}
}
}  // namespace nonlinear
}  // namespace minimum
